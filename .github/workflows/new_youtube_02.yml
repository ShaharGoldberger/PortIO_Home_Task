name: 02 Fetch and Post YouTube Playlists

on:
  schedule:
    - cron: '0 12 * * *'  # Runs daily at 12:00 UTC
  workflow_dispatch:

jobs:
  fetch-and-update-playlists:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fetch YouTube Playlists JSON
        run: |
          mkdir -p playlists
          
          declare -A PLAYLISTS
          PLAYLISTS["PL2B246C13692AEA56&ab"]="maroon5_short_playlist.json"

          API_KEY="${{ secrets.YOUTUBE_API_KEY }}"

          for PLAYLIST_ID in "${!PLAYLISTS[@]}"; do
            FILE_NAME="playlists/${PLAYLISTS[$PLAYLIST_ID]}"
            echo "Fetching playlist: $PLAYLIST_ID -> $FILE_NAME"

            RESPONSE=$(curl -s "https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${PLAYLIST_ID}&key=${API_KEY}")

            echo "$RESPONSE" | jq '.' > "$FILE_NAME"

            if echo "$RESPONSE" | jq -e '.error' >/dev/null; then
              echo "Error fetching playlist: $PLAYLIST_ID"
              cat "$FILE_NAME"
              exit 1
            fi
          done

      - name: Request Access Token
        id: get_token
        env:
          CLIENT_ID: ${{ secrets.CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
        run: |
          response=$(curl -s --request POST \
            --url 'https://api.getport.io/v1/auth/access_token' \
            --header 'Content-Type: application/json' \
            --data '{"clientId":"'"$CLIENT_ID"'", "clientSecret":"'"$CLIENT_SECRET"'"}')
      
          echo "Raw API response: $response"  # Debugging output
      
          access_token=$(echo "$response" | jq -r '.accessToken')  # Correct field name
      
          if [[ -z "$access_token" || "$access_token" == "null" ]]; then
            echo "Error: Failed to retrieve access token!"
            exit 1
          fi
      
          echo "::add-mask::$access_token"
          echo "access_token=$access_token" >> $GITHUB_OUTPUT

      - name: Create/Update Port Entities
        env:
          ACCESS_TOKEN: ${{ steps.get_token.outputs.access_token }}
        run: |
          for FILE in playlists/*.json; do
            echo "Processing $FILE"

            PLAYLIST_ID=$(jq -r '.items[0].snippet.playlistId' "$FILE")
            PLAYLIST_TITLE=$(jq -r '.items[0].snippet.title' "$FILE")
            PLAYLIST_DESCRIPTION=$(jq -r '.items[0].snippet.description' "$FILE")

            # Construct the JSON payload for the playlist
            PLAYLIST_PAYLOAD=$(jq -n --arg id "$PLAYLIST_ID" --arg title "$PLAYLIST_TITLE" --arg description "$PLAYLIST_DESCRIPTION" \
              '{
                identifier: $id,
                title: $title,
                properties: {
                  id: $id,
                  title: $title,
                  description: $description
                }
              }'
            )

            # Check if the playlist entity already exists
            GET_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X GET "https://api.getport.io/v1/blueprints/youtube_playlist/entities/$PLAYLIST_ID" \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json")

            if [ "$GET_RESPONSE" -eq 200 ]; then
              # Entity exists, perform an update
              PLAYLIST_RESPONSE=$(curl -s -X PUT "https://api.getport.io/v1/blueprints/youtube_playlist/entities/$PLAYLIST_ID" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -d "$PLAYLIST_PAYLOAD")
              ACTION="updated"
            elif [ "$GET_RESPONSE" -eq 404 ]; then
              # Entity does not exist, create it
              PLAYLIST_RESPONSE=$(curl -s -X POST "https://api.getport.io/v1/blueprints/youtube_playlist/entities" \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -d "$PLAYLIST_PAYLOAD")
              ACTION="created"
            else
              echo "Error checking existence of playlist entity for ID: $PLAYLIST_ID"
              echo "HTTP response code: $GET_RESPONSE"
              exit 1
            fi

            if echo "$PLAYLIST_RESPONSE" | jq -e '.error' >/dev/null; then
              echo "Error ${ACTION} playlist entity for ID: $PLAYLIST_ID"
              echo "Response: $PLAYLIST_RESPONSE"
              exit 1
            else
              echo "Successfully ${ACTION} playlist entity for ID: $PLAYLIST_ID"
            fi

            # Process each item in the playlist
            jq -c '.items[]' "$FILE" | while read -r ITEM; do
              VIDEO_ID=$(echo "$ITEM" | jq -r '.snippet.resourceId.videoId')
              PUBLISHED_AT=$(echo "$ITEM" | jq -r '.snippet.publishedAt')
              CHANNEL_ID=$(echo "$ITEM" | jq -r '.snippet.channelId')
              TITLE=$(echo "$ITEM" | jq -r '.snippet.title')
              DESCRIPTION=$(echo "$ITEM" | jq -r '.snippet.description')
              THUMBNAILS=$(echo "$ITEM" | jq -c '.snippet.thumbnails')

              if [[ "$VIDEO_ID" == "null" || "$TITLE" == "null" ]]; then
                echo "Skipping invalid playlist item: $ITEM (No valid data)"
                continue
              fi

              # Construct the JSON payload for the playlist item
              ITEM_PAYLOAD=$(jq -n \
                --arg id "$VIDEO_ID" \
                --arg playlistId "$PLAYLIST_ID" \
                --arg publishedAt "$PUBLISHED_AT" \
                --arg channelId "$CHANNEL_ID" ::contentReference[oaicite:0]{index=0}
 
